# 事件循环 



![QQ截图20200203155301.png](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png)

## 为什么JavaScript是单线程？

作为浏览器的脚本语言，js主要用途是和用户交互和操作DOM。（如果js一个线程操作DOM，一个线程删除DOM。会带来同步的问题）

为了利用多核计算能力,HTML5提出Web Woker标准允许js创建多线程，但是子进程完全受控于主线程，且不得操作DOM，（并没有改变js单线程的本质）

## 任务队列

主线程：主线程上执行所有的同步任务，主线成的这些同步任务形成一个执行栈。
任务队列：任务队列是一个事件的队列，

   （所有的事件都是通过回调实现，都是需要放在异步队列中执行（需要指定回调函数，等待主线程清空队列读取异步队列内容），setTimeOut也是在异步队列中执行，可以通过setTimeOut来模拟异步。）
    
## setTimeOut(fn,0)的含义
setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。
HTML5 setTimeout第二个参数最小值不能低于4ms，对于DOM的变动（涉及页面重新渲染的那部分），通常不会立即执行，而是每16ms执行一次。 
所以此时使用requestAnimationFrame（）的效果要好于setTimeOut（）.
setTimeOut()只是把事件插入到任务队列中，必须等到当前代码主线程执行栈执行完，和异步队列现有任务都执行完，才会执行setTimeOut。

## Node.js的事件循环 

### process.nextTick方法
在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。指定的任务总是发生在所有异步任务之前。
```$xslt
    `process.nextTick(function A() {
      console.log(1);
      process.nextTick(function B(){console.log(2);});
    });
    
    setTimeout(function timeout() {
      console.log('TIMEOUT FIRED');
    }, 0)
    // 1
    // 2
    // TIMEOUT FIRED`
```
### setImmediate()方法
在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。
```$xslt
setImmediate(function A() {
  console.log(1);
  setImmediate(function B(){console.log(2);});
});

setTimeout(function timeout() {
  console.log('TIMEOUT FIRED');
}, 0);
```
setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1--TIMEOUT FIRED--2，也可能是TIMEOUT FIRED--1--2。
